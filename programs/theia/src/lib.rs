use anchor_lang::prelude::*;
mod events;
mod states;

pub use events::*;
pub use states::*;

 use theia_uuid_keeper::cpi::accounts::GenerateUuid;
 use theia_uuid_keeper::program::TheiaUuidKeeper;
 use theia_uuid_keeper::Uuid2Nonce;
 use theia_uuid_keeper::CurrentNonce;
 use theia_uuid_keeper::state::EvmData;
 use c_3caller_solana::cpi::accounts::C3CallerState;
 use c_3caller_solana::program::C3callerSolana;
 use c_3caller_solana::states::Pause;
 use c_3caller_solana::states::OwnerKey;
 use c_3caller_solana::states::C3UUIDKeeper;

declare_id!("7AQNimfj3jURLjQzphNHySCBceLaFyAqtF2QcngKS17y");

#[program]
pub mod theia {
    use super::*;


    pub fn initialize(
        ctx: Context<Initialize> ) -> Result<()> {
       
        Ok(())
    }

    // pub fn change_uuid_keeper(ctx: Context<ChangeConfig>, uuid_keeper: Pubkey) -> Result<()> {
    //     let router = &mut ctx.accounts.router;
    //     router.uuid_keeper = uuid_keeper;
    //     emit!(LogChangeUUIDKeeper { uuid_keeper });
    //     Ok(())
    // }

    // pub fn change_theia_config(ctx: Context<ChangeConfig>, theia_config: Pubkey) -> Result<()> {
    //     let router = &mut ctx.accounts.router;
    //     router.theia_config = theia_config;
    //     emit!(LogChangeTheiaConfig { theia_config });
    //     Ok(())
    // }

    // pub fn change_fee_manager(ctx: Context<ChangeConfig>, fee_manager: Pubkey) -> Result<()> {
    //     let router = &mut ctx.accounts.router;
    //     router.fee_manager = fee_manager;
    //     emit!(LogChangeFeeManager { fee_manager });
    //     Ok(())
    // }

    // pub fn set_minter(ctx: Context<SetMinter>, token: Pubkey, auth: Pubkey) -> Result<()> {
    //     // Implement set_minter logic here
    //     Ok(())
    // }

    // pub fn apply_minter(ctx: Context<ApplyMinter>, token: Pubkey) -> Result<()> {
    //     // Implement apply_minter logic here
    //     Ok(())
    // }

    // pub fn revoke_minter(ctx: Context<RevokeMinter>, token: Pubkey, auth: Pubkey) -> Result<()> {
    //     // Implement revoke_minter logic here
    //     Ok(())
    // }

    // pub fn get_liquidity(ctx: Context<GetLiquidity>, token: Pubkey) -> Result<(u64, u8)> {
    //     let (liquidity, decimals) = ctx.accounts.router.get_liquidity(token)?;
    //     Ok((liquidity, decimals))
    // }

    // pub fn query_liquidity_fee_rate(ctx: Context<QueryLiquidityFeeRate>, theia_token: Pubkey, amount: u64) -> Result<u64> {
    //     let router = &ctx.accounts.router;
    //     let fee_rate = router.query_liquidity_fee_rate(theia_token, amount)?;
    //     let base_fee = router.get_base_liquidity_fee(theia_token)?;
    //     let fee = (base_fee * fee_rate) / 1000;
    //     Ok(fee)
    // }


    pub fn theia_cross_non_evm(ctx: Context<TheiaCrossNonEvm>) -> Result<()>{

        
        //check if the params are valid

        //get _revAmount from getRevAmount()
         // generate the uuid by cpi into uuid keeper

         //  get swap fee  from _calcAndPay()

         // geneerate calldata and cpi into c3caller

         // then emit event
        Ok(())
    }

    pub fn theia_cross_evm(ctx: Context<TheiaCrossEvm>, params: CrossAuto) -> Result<()>{




        let recv_amount = params.amount;
        let t = params.token_id;
        let cpi_ctx = CpiContext::new(ctx.accounts.theia_uuid_keeper.to_account_info(), GenerateUuid{
            uuid_nonce: ctx.accounts.uuid_nonce.to_account_info(),
            payer: ctx.accounts.payer.to_account_info(),
            current_nonce: ctx.accounts.current_nonce.to_account_info(),
            system_program: ctx.accounts.system_program.to_account_info(),
        });




        let uuid:[u8;32];
        let res = theia_uuid_keeper::cpi::gen_uuid_evm(cpi_ctx, EvmData {
            token: params.token_id,
            from: ctx.accounts.payer.key().to_string(),
            amount: recv_amount,
            receiver: params.receiver,
            to_chain_id: params.to_chain_id,
        });

        
        match res {
            Ok(_uuid) => uuid = _uuid.get(),
            Err(err) => msg!(&err.to_string()),
        }
            
        
       

        // Check if the params are valid
        // TODO: Implement parameter validation

        // Get _revAmount from getRevAmount()
        // TODO: Implement getRevAmount() function and call it here

        // UUID has been generated by CPI into uuid keeper

         //  get swap fee  from _calcAndPay()

         // geneerate calldata and cpi into c3caller
         let swap_fee = 0;
         let token_info = TokenInfo {
             addr: "".to_string(), // Replace with actual token address
             decimals: 8, // Replace with actual decimals
             to_chain_addr: "".to_string(), // Replace with actual to_chain_addr
             to_chain_decimals: 8, // Replace with actual to_chain_decimals
         };
         let fee_token_info = TokenInfo {
             addr: "".to_string(), // Replace with actual fee token address
             decimals: 8, // Replace with actual fee token decimals
             to_chain_addr: "".to_string(), // Replace with actual fee token to_chain_addr
             to_chain_decimals: 8, // Replace with actual fee token to_chain_decimals
         };
         let data = gen_calldata(uuid, recv_amount, swap_fee, params, token_info, fee_token_info);

        let ctx_caller = CpiContext::new(ctx.accounts.c3_caller.to_account_info(), C3CallerState {
            pause: ctx.accounts.pause.to_account_info(),
            owner: ctx.accounts.owner_key.to_account_info(),
            c3_uuid: ctx.accounts.c3_uuid.to_account_info(),
            signer: ctx.accounts.payer.to_account_info(),
            event_authority: ctx.accounts.payer.to_account_info(),
            program: ctx.accounts.c3_caller.to_account_info(),
        });

        let res_caller = c_3caller_solana::cpi::ccall(
            ctx_caller,
            42,  // Dummy value for the first u64 parameter
            Pubkey::new_unique(),
            "".to_string(),
            "".to_string(),
            Pubkey::new_unique().to_bytes().to_vec(),
            Pubkey::new_unique().to_bytes().to_vec()
        );

         //todo cpi into c3caller

         // then emit event
        emit!(
            LogTheiaCross{
                token: params.token_id,
                from: "".to_string(),
                swapout_id: uuid, 
                amount: recv_amount,
                from_chain_id: 10, 
                to_chain_id: params.to_chain_id,
                fee: swap_fee, 
                fee_token: "text".to_string(),
                receiver: params.receiver,
            }
        );
        
        Ok(())

    }

//     pub fn theia_vault_auto(ctx: Context<TheiaVaultAuto>, params: VaultAuto) -> Result<()>{

     
         





//         Ok(())

//     }

  
// }

// pub fn _get_rev_amount(ctx: Context<TheiaVaultAuto>, params: VaultAuto) -> Result<()>{


//     // transfer native vs transfer

//     Ok(())

 }


 pub fn gen_calldata(uuid:[u8;32], recv_amount:u64, swap_fee:u64,tc:CrossAuto, t:TokenInfo,fee:TokenInfo)->Vec<u8>{

    let to_amount = recv_amount;
    let liquidty_fee:u64 = 0;

    let func_sign_theia = "0x3a1f8688";//"theiaVaultAuto(bytes32,address,address,uint256,uint256,uint256,address,address)";

    let mut call_data = Vec::new();
    // call_data.extend_from_slice(func_sign_theia.as_bytes());
    // call_data.extend_from_slice(&uuid);
    // call_data.extend_from_slice(t.to_chain_addr.as_bytes());
    // call_data.extend_from_slice(tc.receiver.as_bytes());
    // call_data.extend_from_slice(&to_amount.to_le_bytes());
    // call_data.extend_from_slice(&[t.to_chain_decimals]);
    // call_data.extend_from_slice(&(liquidty_fee as u64).to_le_bytes());
    // call_data.extend_from_slice(fee.to_chain_addr.as_bytes());
    // call_data.extend_from_slice(t.addr.as_bytes());

    call_data
}
#[derive(Accounts)]
pub struct Initialize<'info> {
   

    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct TheiaCrossNonEvm<'info>{
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct TheiaCrossEvm<'info>{
    #[account(mut)]
    pub theia_uuid_keeper: Program<'info, TheiaUuidKeeper>,
    pub uuid_nonce: Account<'info, Uuid2Nonce>,
    pub current_nonce: Account<'info, CurrentNonce>,
    pub payer: Signer<'info>,
    pub c3_caller: Program<'info, C3callerSolana>,
    pub c3_uuid: Account<'info, C3UUIDKeeper>,
    pub pause: Account<'info, Pause>,
    pub owner_key: Account<'info, OwnerKey>, 
    pub system_program: Program<'info, System>,
}

// #[derive(Accounts)]
// pub struct ChangeConfig<'info> {
//     #[account(mut, has_one = gov)]
//     pub router: Account<'info, TheiaRouter>,
//     pub gov: Signer<'info>,
// }

// #[derive(Accounts)]
// pub struct SetMinter<'info> {
//     #[account(mut, has_one = gov)]
//     pub router: Account<'info, TheiaRouter>,
//     pub gov: Signer<'info>,
//     /// CHECK: This account is checked in the instruction
//     pub token: AccountInfo<'info>,
// }

// #[derive(Accounts)]
// pub struct ApplyMinter<'info> {
//     #[account(mut, has_one = gov)]
//     pub router: Account<'info, TheiaRouter>,
//     pub gov: Signer<'info>,
//     /// CHECK: This account is checked in the instruction
//     pub token: AccountInfo<'info>,
// }

// #[derive(Accounts)]
// pub struct RevokeMinter<'info> {
//     #[account(mut, has_one = gov)]
//     pub router: Account<'info, TheiaRouter>,
//     pub gov: Signer<'info>,
//     /// CHECK: This account is checked in the instruction
//     pub token: AccountInfo<'info>,
// }

// #[derive(Accounts)]
// pub struct GetLiquidity<'info> {
//     pub router: Account<'info, TheiaRouter>,
//     /// CHECK: This account is checked in the instruction
//     pub token: AccountInfo<'info>,
// }

// #[derive(Accounts)]
// pub struct QueryLiquidityFeeRate<'info> {
//     pub router: Account<'info, TheiaRouter>,
//     /// CHECK: This account is checked in the instruction
//     pub theia_token: AccountInfo<'info>,
// }


#[error_code]
pub enum TheiaRouterError {
    #[msg("Invalid input")]
    InvalidInput,
    // Add other error codes here...
}



